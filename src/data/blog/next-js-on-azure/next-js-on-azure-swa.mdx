---
title: Deploying Next-JS to Azure Static Web Apps using Bicep and GitHub Actions
date: '2024-05-01'
tags: ['next-js', 'azure', 'docker', 'static-web-apps', 'github-actions', 'bicep', 'bpmn']
draft: false
summary: Explaining how to deploy Next-JS to Static Web Apps using GitHub Actions
---

![Next-JS and SWA](/static/images/next_swa.png)


In the second part of this series, we will look at deploying Next-JS to 
Azure Static Web Apps using GitHub Actions and Bicep.

## Source Control Strategy

For the purposes of this article and in general we subscribe to the [Feature-Branch workflow](https://www.atlassian.com/git/tutorials/comparing-workflows/feature-branch-workflow).
We only have a single main branch, but develop features in isolation and use the Pull-Request mechanism to 
trigger a review and subsequent merge.

## Workflows

To consider our target workflow in abstract, a useful tool is [BPMN](https://www.bpmn.org/). Firstly just considering
what happens when a PR is merged into main or a commit is directly pushed (shouldn't happen but does at the start of a project or in emergencies).

### Main Branch Workflow
![Workflow Diagram](/static/images/swa_bpmn_main.svg)

This is a simplified workflow to demonstrate they key stages involved in a typical CI/CD process. 

Applied to our scenario, the steps translate as follows: 

1. Validate Entry Criteria: We use a path filter to look for changes in the **src** or **infra** folders.
2. Execute Build: In the case of this example we use node to build our Next-JS site. As it's a simple blog so
we export as a static site. This step includes linting and type-checking.
3. Run integration tests: For demo purposes we have some (very) basic Jest integration tests.
4. Provision Staging Environment: An Azure Static Web App comes with environments built-in, so this and step 5 are replaced with 
a generic **base_infra** step that runs before the application build. This applies the Bicep Infrastructure as Code files 
based on the environment variables in GitHub.
5. Deploy to Staging Environment: We deploy the build to a staging environment using the official [GitHub Action](https://github.com/Azure/static-web-apps-deploy?tab=readme-ov-file) for static web apps.
This uses the [Oryx](https://github.com/microsoft/Oryx) build system which downloads a docker container to wrap CLI logic we would otherise implement manually. 
Here we want to perform e2e tests in an environment as similar as possible to production without affecting the live site.
6. Run E2E Tests: We use (very) simple PlayWright tests as Browser-based UI testing. This includes Firefox, Chrome and WebKit.
7. Provision Production Environment: See step 4.
8. Deploy to Production: Repeat step 5 but targeting the production environment.

#### YAML
Here is an example [yaml](https://github.com/canary-ops/blog/blob/main/.github/workflows/swa-main.yml) based on the main workflow for this blog.

```yml:swa-main.yml
 name: Build and Push to Static Web App (Main)

on:
  push:
    branches:
      - main

jobs:
  validate_entry:
    runs-on: ubuntu-latest
    outputs:
      infra: ${{ steps.filter.outputs.infra }}
      src: ${{ steps.filter.outputs.src }}
    steps:
      - uses: actions/checkout@v4
      - uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            infra:
               - 'infra/**'
            src:
               - 'src/**'

  deploy_base_infra:
    needs: validate_entry
    if: needs.validate_entry.outputs.infra || needs.validate_entry.outputs.src
    secrets: inherit
    uses: ./.github/workflows/base_infra_swa.yml

  build_job:
    needs: deploy_base_infra
    if: needs.validate_entry.outputs.src
    runs-on: ubuntu-latest
    name: Build Job
    env:
      NEXT_UMAMI_ID: ${{ secrets.NEXT_UMAMI_ID }}
      NEXT_PUBLIC_GISCUS_REPO: ${{ vars.NEXT_PUBLIC_GISCUS_REPO }}
      NEXT_PUBLIC_GISCUS_REPOSITORY_ID: ${{ vars.NEXT_PUBLIC_GISCUS_REPOSITORY_ID }}
      NEXT_PUBLIC_GISCUS_CATEGORY: ${{ vars.NEXT_PUBLIC_GISCUS_CATEGORY }}
      NEXT_PUBLIC_GISCUS_CATEGORY_ID: ${{ vars.NEXT_PUBLIC_GISCUS_CATEGORY_ID }}
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: true
          lfs: false

      - name: Use Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20.x"
          cache: "npm"
          cache-dependency-path: "src/package-lock.json"

      - name: run npm commands
        working-directory: src
        run: |
          npm i --legacy-peer-deps
          npm run build

      - name: Upload build folder
        uses: actions/upload-artifact@v4
        with:
          name: build
          path: src/out

  run_integration_tests:
    needs: build_job
    secrets: inherit
    uses: ./.github/workflows/jest.yml

  deploy_to_staging:
    needs: run_integration_tests
    runs-on: ubuntu-latest
    name: Deploy to Staging
    environment: staging
    steps:
      - name: Download build
        uses: actions/download-artifact@v4
        with:
          name: build
          path: build

      - name: "Login to Azure"
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get Deployment Token for Static Web App
        uses: azure/CLI@v1
        with:
          inlineScript: |
            APIKEY=$(az staticwebapp secrets list --name ${{ vars.SWA_APP_NAME }} | jq -r '.properties.apiKey')
            echo "STATIC_DEPLOYMENT_TOKEN=$APIKEY" >> $GITHUB_ENV

      - name: Deploy to Staging
        id: deploy_to_staging
        uses: Azure/static-web-apps-deploy@v1
        with:
          azure_static_web_apps_api_token: ${{ env.STATIC_DEPLOYMENT_TOKEN }}
          repo_token: ${{ secrets.GITHUB_TOKEN }} # Used for Github integrations (i.e. PR comments)
          action: "upload"
          skip_app_build: true
          deployment_environment: staging
          app_location: "build"
    outputs:
      staging_url: ${{ steps.deploy_to_staging.outputs.static_web_app_url }}

  run_e2e_tests_staging:
    needs: deploy_to_staging
    secrets: inherit
    uses: ./.github/workflows/playwright.yml
    with:
      baseUrl: ${{ needs.deploy_to_staging.outputs.staging_url }}
      useExternal: true

  deploy_to_production:
    runs-on: ubuntu-latest
    needs: run_e2e_tests_staging
    name: Deploy to Production
    environment: production
    steps:
      - name: Download build
        uses: actions/download-artifact@v4
        with:
          name: build
          path: build

      - name: "Login to Azure"
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get Deployment Token for Static Web App
        uses: azure/CLI@v1
        with:
          inlineScript: |
            APIKEY=$(az staticwebapp secrets list --name ${{ vars.SWA_APP_NAME }} | jq -r '.properties.apiKey')
            echo "STATIC_DEPLOYMENT_TOKEN=$APIKEY" >> $GITHUB_ENV

      - name: Deploy to Prod
        uses: Azure/static-web-apps-deploy@v1
        with:
          azure_static_web_apps_api_token: ${{ env.STATIC_DEPLOYMENT_TOKEN }}
          repo_token: ${{ secrets.GITHUB_TOKEN }} # Used for Github integrations (i.e. PR comments)
          action: "upload"
          skip_app_build: true
          environment: production
          app_location: "build"
```

#### YAML
Here is an example [yaml](https://github.com/canary-ops/blog/blob/main/.github/workflows/swa-pr.yml) based on the PR workflow for this blog.

```yml:swa-pr.yml
name: Build and Push to Static Web App (PR)

on:
  pull_request:
    types: [opened, synchronize, reopened, closed]
    branches:
      - main

jobs:
  validate_entry:
    runs-on: ubuntu-latest
    outputs:
      infra: ${{ steps.filter.outputs.infra }}
      src: ${{ steps.filter.outputs.src }}
    steps:
      - uses: actions/checkout@v4
      - uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            infra:
               - 'infra/**'
            src:
               - 'src/**'

  validate_bicep:
    secrets: inherit
    needs: validate_entry
    if: needs.validate_entry.outputs.infra
    uses: ./.github/workflows/bicep_what_if.yml
    with:
      bicepMainPath: "./infra/swa/main.bicep"
      params: "appName=${{ vars.SWA_APP_NAME }}"
      resourceGroup: ${{ vars.SWA_RG }}

  build_job:
    if: github.event_name == 'pull_request' && github.event.action != 'closed' && needs.validate_entry.outputs.src
    runs-on: ubuntu-latest
    name: Build Job
    needs: validate_entry
    env:
      NEXT_UMAMI_ID: ${{ secrets.NEXT_UMAMI_ID }}
      NEXT_PUBLIC_GISCUS_REPO: ${{ vars.NEXT_PUBLIC_GISCUS_REPO }}
      NEXT_PUBLIC_GISCUS_REPOSITORY_ID: ${{ vars.NEXT_PUBLIC_GISCUS_REPOSITORY_ID }}
      NEXT_PUBLIC_GISCUS_CATEGORY: ${{ vars.NEXT_PUBLIC_GISCUS_CATEGORY }}
      NEXT_PUBLIC_GISCUS_CATEGORY_ID: ${{ vars.NEXT_PUBLIC_GISCUS_CATEGORY_ID }}
    steps:
      - uses: actions/checkout@v3
        with:
          submodules: true
          lfs: false

      - name: "Only run if code (not infra) has changed"
        uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            src:
              - 'src/**'

      - name: Use Node.js
        uses: actions/setup-node@v3
        with:
          node-version: "20.x"
          cache: "npm"
          cache-dependency-path: "src/package-lock.json"

      - name: run npm commands
        working-directory: src
        run: |
          npm i --legacy-peer-deps
          npm run build

      - name: Upload build folder
        uses: actions/upload-artifact@v4
        with:
          name: build
          path: src/out

  run_integration_tests:
    needs: build_job
    secrets: inherit
    uses: ./.github/workflows/jest.yml

  deploy_to_preview:
    if: github.event_name == 'pull_request' && github.event.action != 'closed'
    runs-on: ubuntu-latest
    needs: run_integration_tests
    name: Deploy to Preview
    steps:
      - name: Download build
        uses: actions/download-artifact@v4
        with:
          name: build
          path: build

      - name: "Login to Azure"
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get Deployment Token for Static Web App
        uses: azure/CLI@v1
        with:
          inlineScript: |
            APIKEY=$(az staticwebapp secrets list --name ${{ vars.SWA_APP_NAME }} | jq -r '.properties.apiKey')
            echo "STATIC_DEPLOYMENT_TOKEN=$APIKEY" >> $GITHUB_ENV

      - name: Deploy to Preview
        uses: Azure/static-web-apps-deploy@v1
        with:
          azure_static_web_apps_api_token: ${{ env.STATIC_DEPLOYMENT_TOKEN }}
          repo_token: ${{ secrets.GITHUB_TOKEN }} # Used for Github integrations (i.e. PR comments)
          action: "upload"
          skip_app_build: true
          app_location: "build"

  close_pull_request_job:
    if: github.event_name == 'pull_request' && github.event.action == 'closed'
    runs-on: ubuntu-latest
    name: Close Pull Request Job
    steps:
      - name: "Login to Azure"
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get Deployment Token for Static Web App
        uses: azure/CLI@v1
        with:
          inlineScript: |
            resourceName=$(az resource list --resource-group $(resourceGroupName) --resource-type 'Microsoft.Web/staticSites' --query [].name --output tsv)
            APIKEY=$(az staticwebapp secrets list --name $resourceName | jq -r '.properties.apiKey')
            echo "STATIC_DEPLOYMENT_TOKEN=$APIKEY" >> $GITHUB_ENV

      - name: Close Pull Request
        id: closepullrequest
        uses: Azure/static-web-apps-deploy@v1
        with:
          azure_static_web_apps_api_token: ${{ env.STATIC_DEPLOYMENT_TOKEN }}
          action: "close"

```

## Extensions

This is a simple example. This could be extended to include:

- Static Code Analysis steps.
- Unit Tests.
- Smoke Tests after a Production Deployment.
- Load Tests.
- Penetration Tests.
- Infrastructure Validation after a deployment.
- Manual Control for production deployment.
- Progressive Rollout or Canary Deployments (Potentially use Traffic Splitting feature for this in Static Web Apps).
- Expand PlayWright to test logic such as contact form submission.

In the next article, we will look at implementing a similar workflow for Blob Storage Hosting.