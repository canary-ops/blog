---
title: Deploying Next-JS to Azure Static Web Apps using Bicep and GitHub Actions
date: '2024-05-01'
tags: ['next-js', 'azure', 'docker', 'static-web-apps', 'github-actions', 'bicep', 'bpmn']
draft: false
summary: Explaining how to deploy Next-JS to Static Web Apps using GitHub Actions
---

![Next-JS and SWA](/static/images/next_swa.png)


In the second part of this series, we will look at deploying Next-JS to 
Azure Static Web Apps using GitHub Actions and Bicep.

## Source Control Strategy

For the purposes of this article and in general we subscribe to the [Feature-Branch workflow](https://www.atlassian.com/git/tutorials/comparing-workflows/feature-branch-workflow).
We only have a single main branch, but develop features in isolation and use the Pull-Request mechanism to 
trigger a review and subsequent merge.

## Workflows

To consider our target workflow in abstract, a useful tool is [BPMN](https://www.bpmn.org/). Firstly just considering
what happens when a PR is merged into main or a commit is directly pushed (shouldn't happen but does at the start of a project or in emergencies).

### Main Branch Workflow
![Workflow Diagram](/static/images/swa_bpmn_main.svg)

This is a simplified workflow to demonstrate they key stages involved in a typical CI/CD process. 

Applied to our scenario, the steps translate as follows: 

1. Execute Build: In the case of this example we use node to build our Next-JS site. As it's a simple blog so
we export as a static site. This step includes linting and type-checking.
2. Run integration tests: For demo purposes we have some (very) basic Jest integration tests.
3. Provision Staging Environment: An Azure Static Web App comes with environments built-in, so this and step 5 are replaced with 
a generic step **base_infra** step that runs before the application build. This applies the Bicep Infrastructure as Code files 
based on the environment variables in GitHub.
4. Deploy to Staging Environment: We deploy the build to a staging environment using the official [GitHub Action](https://github.com/Azure/static-web-apps-deploy?tab=readme-ov-file) for static web apps.
This uses the [Oryx](https://github.com/microsoft/Oryx) build system which downloads a docker container to wrap CLI logic we would otherise implement manually. 
Here we want to perform e2e tests in an environment as similar as possible to production without affecting the live site.
5. Run E2E Tests: We use (very) simple PlayWright tests as Browser-based UI testing. This includes Firefox, Chrome and WebKit.
5. Provision Production Environment: See step 3.
6. Deploy to Production: Repeat step 4 but targeting the production environment.

#### YAML
Here is an example [yaml](https://github.com/canary-ops/blog/blob/main/.github/workflows/swa-main.yml) based on the main workflow for this blog.

### PR Workflow
![Workflow Diagram](/static/images/swa_bpmn_pr.svg)

For a PR, we want a simplified workflow that won't affect production but providers testers or developers
a dedicated environment to review the PR. We also want to validate and assess any changes to Bicep code. One 
limitation of using a static web app environments is that you can't easily review Bicep changes 
without affecting the production site. So we settle for a **what-if** deployment and validation 
as the basis for PR approval.

Applied to our scenario, the steps translate as follows: 

- If the PR includes Bicep changes, we validate and run the **what-if** deployment. This gives us a report 
of changes that will be executed. We write this report to the PR in GitHub.
- If the PR includes source changes, we follow these steps:
    1. Execute Build: Similarly to the main pipeline we use node to build and export our Next-JS site. This includes linting and
    type checking.
    2. Run Integration Tests: We run our Jest tests.
    3. Provision Preview Environment: This functionality is again, built in to Static Web Apps. When we execute the following steps
       the [Oryx](https://github.com/microsoft/Oryx) tool will handle provisioning an environment based on the PR name. 
    4. We deploy to a Preview Environment with a URL specific to this PR. Similar to steps 4 and 6 in the main pipeline we 
    leverage the official [GitHub Action](https://github.com/Azure/static-web-apps-deploy?tab=readme-ov-file) for static web apps.

#### YAML
Here is an example [yaml](https://github.com/canary-ops/blog/blob/main/.github/workflows/swa-pr.yml) based on the PR workflow for this blog.

## Extensions

This is a simple example. This could be extended to include:

- Static Code Analysis steps.
- Unit Tests.
- Smoke Tests after a Production Deployment.
- Load Tests.
- Penetration Tests.
- Infrastructure Validation after a deployment.
- Manual Control for production deployment.
- Progressive Rollout or Canary Deployments (Potentially use Traffic Splitting feature for this in Static Web Apps).
- Expand PlayWright to test logic such as contact form submission.

In the next article, we will look at implementing a similar workflow for Blob Storage Hosting.